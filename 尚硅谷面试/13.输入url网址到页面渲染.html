<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /*
      从一个url地址到最终页面渲染完成，发生了什么？
        1.DNS解析：将域名地址解析为ip地址
          -浏览器DNS缓存
          -系统DNS缓存
          -路由器DNS缓存
          -网络运营商DNS缓存
          -递归搜索：blog.baidu.com
              1 .com域名下查找DNS解析
              2 .baidu域名下查找DNS解析
              3 .blog域名下查找DNS解析
        2.TCP连接：TCP三次握手
          -第一次握手，由浏览器发起，告诉服务器我要发送请求了
          -第二次握手，由服务器发起，告诉浏览器我准备接收了，你赶紧发吧
          -第三次握手，由浏览器发起，告诉服务器，我马上就发了，准备接受吧
        3.发送请求
          -请求报文：http协议的通信内容
        4.接受响应
          -响应报文
        5.渲染页面
          -遇见HTML标记，浏览器调用HTML解析器解析成Token并构建成dom树
          -遇见style/link标记，浏览器调用css解析器，处理css标记并构建cssom树
          -遇到script标记，调用js解析器，处理script代码（绑定事件、修改dom树/cssom树）
          -将dom树和cssom树合并成一个渲染树
          -根据渲染树来计算布局，计算每个节点的几何信息（布局）
          -将各个节点的颜色绘制到屏幕上（渲染）
          注：
             这五个步骤不一定按照步骤执行，如果dom树或cssom树被修改了，可能会执行多次布局和渲染
             往往在实际页面中，这些步骤都会执行多次的。
        6.断开：TCP四次挥手  ACK报文是用来应答的，SYN报文是用来同步的。
          -第一次挥手，由浏览器发起的，发送给服务器，我东西发送完了（请求报文），你准备关闭把
          -第二次挥手，由服务器发起，告诉浏览器，我东西接收完了（请求报文），我准备关闭了，你也准备吧
          -第三次挥手，由服务器发起，告诉浏览器，我东西发送完了（响应报文），你准备关闭吧
          -第四次挥手，由浏览器发起，告诉服务器，我东西接收完了，我准备关闭了（响应报文），你也准备吧

    为什么要三次握手？
       原因一：
                如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，服务器端是不知道客户端有没有接收到服务器端返回的信息的。
            服务端就认为这个连接是可用的，端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。
            这样一来，就会有很多无效的连接端口白白地开着，导致资源的浪费。
       原因二：
                已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。
+

            通过第三次握手的数据告诉服务端，客户端有没有收到服务器“第二次握手”时传过去的数据，以及这个连接的序号是不是有效的。
        若发送的这个数据是“收到且没有问题”的信息，接收后服务器就正常建立 TCP 连接，否则建立 TCP  连接失败，服务器关闭连接端口。
        由此减少服务器开销和接收到失效请求发生的错误。

    为什么要四次挥手？
        四次挥手双方发 FIN 包的过程，就能理解为什么需要四次了。
            1.关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
            2.服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，
              等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。
        从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。
    
    为什么客户端在TIME-WAIT阶段要等2MSL？
        为的是确认服务器端是否收到客户端发出的 ACK 确认报文，当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。
        所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2MSL 的计时器。

        MSL 指的是 Maximum Segment Lifetime：一段 TCP 报文在传输过程中的最大生命周期。
        2MSL 即是服务器端发出为 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。

        服务器端在 1MSL 内没有收到客户端发出的 ACK 确认报文，就会再次向客户端发出 FIN 报文：
            如果客户端在 2MSL 内，再次收到了来自服务器端的 FIN 报文，说明服务器端由于各种原因没有接收到客户端发出的 ACK 确认报文。
        客户端再次向服务器端发出 ACK 确认报文，计时器重置，重新开始 2MSL 的计时。
            否则客户端在 2MSL 内没有再次收到来自服务器端的 FIN 报文，说明服务器端正常接收了 ACK 确认报文，客户端可以进入 CLOSED  阶段，完成“四次挥手”。
            
        所以，客户端要经历时长为 2SML 的 TIME-WAIT 阶段;这也是为什么客户端比服务器端晚进入 CLOSED 阶段的原因。

    */
  </script>
</body>

</html>